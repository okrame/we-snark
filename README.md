# Mini Witness Encryption with LV-SNARK

This repo is a tiny end-to-end prototype of Witness Encryption built from a linearly verifiable (LV) SNARK-like gadget stack (see this https://eprint.iacr.org/2025/1364).
The NP relation supported is:

$$
x \cdot y = z
$$

Everything runs on BN254 using arkworks crates.


> Note: This captures a tiny linearly verifiable gadget stack for a fixed constraint system and should not be confused with a general-purpose WE construction. Standard bilinear groups only provide degree-2 structure, so collapsing the verification of arbitrary circuits into a single GT-linear equation would require stronger primitives such as multilinear maps.

## What’s going on?

We build a set of GT-linear gadgets (IIP, NonZero, Mul, QAP-binding) whose combined verification collapses into a single linear check:

$$
A \cdot \pi = b
$$

Here the proof $\pi$ is a vector of GT coordinates derived from the witness.

* The encryptor uses only the public LV digest $(A, b)$ to encrypt. That means that the encryptor never sees the values of $x,y,z$ and never needs to construct a proof.

* The decryptor knows the witness $(x,y,z)$, locally builds the LV proof $\pi$, checks the LV system, and recovers the symmetric key.

So, if you don’t know a valid $(x,y,z)$ with $x \cdot y = z$, you cannot reconstruct $\pi$, and the decryption key stays hidden.

## Gadget stack

The linearly verifiable proof system is built by composing several gadgets. Each gadget contributes a few GT coordinates and one linear constraint. Together they enforce the full relation for this prototype. 

* **IIP** (Inner-product / indexing gadget):
  
  Extracts the witness values from the witness vector $w = [x, y, z, 1]$ and exposes them linearly in (GT) via selector vectors.

* **NonZero**:
  enforces that the last slot of the witness is $1$. This gives the system a fixed unit slot needed by other gadgets.

* **MaxDeg**:
  enforces that the polynomial interpolating the witness vector has degree at most $d = n-1$. This ensures that identities that hold at the hidden point $\tau$ really correspond to true polynomial identities.

* **Mul**:
  enforces multiplicative consistency using a QAP-style constraint:

  * $A(\tau) = x$
  * $B(\tau) = y$
  * $C(\tau) = z$
  * $P(\tau) = A(\tau) B(\tau) - C(\tau)$
  * $P(\tau) = H(\tau) Z(\tau)$

* **C–z binding**:
  ensures that the polynomial output $C$ encodes the same $z$ exposed by the IIP gadget.

All these constraints are flattened into GT coordinates `c0 … c17` and a handful of rows. So, no field-side `x * y == z` check is needed because the gadgets enforce it.

## Encryption flow

Encryptor needs:

* the public LV parameters for the relation (i.e. matrix shape and column metadata derived from the CRS),
* a message

**Steps**

1. Sample randomness vector $s$

2. Compute
   $$c = s \cdot A$$
   (Header consisting of elements in source groups $G_1, G_2$)
   $$K_{GT} = s \cdot b,\qquad k = \text{KDF}(K_{GT})$$
   where $K_{GT}$ is the secret in $GT$ and $k$ is the derived symmetric key.

3. Encrypt the plaintext using AES-GCM with key $k$.

4. Output:

   ```
   { LVHeader (c), AES_nonce, AES_tag, AES_ciphertext }
   ```

## Decryption flow

Decryptor once knowing the witness:

**Steps**

1. Build the witness vector
   $$w = [x, y, z, 1]$$

2. Run the gadgets to compute the LV proof $\pi$.

3. Check linear consistency:
   $$A \cdot \pi = b$$

4. Recover shared secret via pairing and derive key:
   $$K_{GT} = \langle c, \pi \rangle \quad (\text{equivalent to } s \cdot b)$$
   $$k = \text{KDF}(K_{GT})$$

5. AES-GCM decrypt using $k$.

If the witness is invalid, the LV pairing product $\langle c, \pi \rangle$ will not equal the original $K_{GT}$ generated by the encryptor. Consequently, the derived key $k$ will be incorrect, and the AES-GCM decryption will fail.


## Language-level vs Instance-level WE

Right now, the LV digest represents the language

$$L = {(x,y,z) \mid x \cdot y = z},$$

so the encryptor does not need to know any specific $z_0$.

To obtain *instance-specific* WE (e.g., “decrypt only if $x \cdot y = z_0$”), we can extend the LV digest to bake in the public value $z_0$.
The encryptor would still remain oblivious to $(x,y)$ and never handles a witness.